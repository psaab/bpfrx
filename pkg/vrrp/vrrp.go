// Package vrrp manages keepalived configuration for VRRP high availability.
package vrrp

import (
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"strings"

	"github.com/psaab/bpfrx/pkg/config"
)

// Instance describes a single VRRP instance to configure in keepalived.
type Instance struct {
	Interface        string
	GroupID          int
	Priority         int
	Preempt          bool
	AcceptData       bool
	AdvertiseInterval int
	VirtualAddresses []string // CIDR notation
	AuthType         string   // "" or "md5"
	AuthKey          string
	TrackInterface   string
	TrackPriorityCost int
}

// CollectInstances extracts VRRP instances from the interface config.
func CollectInstances(cfg *config.Config) []*Instance {
	if cfg == nil {
		return nil
	}
	var instances []*Instance
	for ifName, ifc := range cfg.Interfaces.Interfaces {
		for _, unit := range ifc.Units {
			for _, vg := range unit.VRRPGroups {
				inst := &Instance{
					Interface:         ifName,
					GroupID:           vg.ID,
					Priority:          vg.Priority,
					Preempt:           vg.Preempt,
					AcceptData:        vg.AcceptData,
					AdvertiseInterval: vg.AdvertiseInterval,
					VirtualAddresses:  vg.VirtualAddresses,
					AuthType:          vg.AuthType,
					AuthKey:           vg.AuthKey,
					TrackInterface:    vg.TrackInterface,
					TrackPriorityCost: vg.TrackPriorityDelta,
				}
				if inst.AdvertiseInterval == 0 {
					inst.AdvertiseInterval = 1
				}
				instances = append(instances, inst)
			}
		}
	}
	return instances
}

const keepalivedConf = "/etc/keepalived/keepalived.conf"

// Apply generates the keepalived config and manages the service.
func Apply(instances []*Instance) error {
	if len(instances) == 0 {
		// No VRRP configured — stop keepalived if running
		_ = exec.Command("systemctl", "stop", "keepalived").Run()
		return nil
	}

	confContent := generateConfig(instances)

	// Ensure directory exists
	if err := os.MkdirAll("/etc/keepalived", 0755); err != nil {
		return fmt.Errorf("mkdir /etc/keepalived: %w", err)
	}

	if err := os.WriteFile(keepalivedConf, []byte(confContent), 0644); err != nil {
		return fmt.Errorf("write keepalived.conf: %w", err)
	}
	slog.Info("keepalived config written", "instances", len(instances))

	// Enable and start/reload keepalived
	_ = exec.Command("systemctl", "enable", "keepalived").Run()
	if err := exec.Command("systemctl", "reload-or-restart", "keepalived").Run(); err != nil {
		return fmt.Errorf("reload keepalived: %w", err)
	}
	return nil
}

func generateConfig(instances []*Instance) string {
	var sb strings.Builder
	sb.WriteString("# Generated by bpfrx — do not edit\n\n")

	for _, inst := range instances {
		name := fmt.Sprintf("VI_%s_%d", inst.Interface, inst.GroupID)
		sb.WriteString(fmt.Sprintf("vrrp_instance %s {\n", name))
		sb.WriteString("    state BACKUP\n") // always start as BACKUP; preempt handles promotion
		sb.WriteString(fmt.Sprintf("    interface %s\n", inst.Interface))
		sb.WriteString(fmt.Sprintf("    virtual_router_id %d\n", inst.GroupID))
		sb.WriteString(fmt.Sprintf("    priority %d\n", inst.Priority))
		sb.WriteString(fmt.Sprintf("    advert_int %d\n", inst.AdvertiseInterval))
		if !inst.Preempt {
			sb.WriteString("    nopreempt\n")
		}
		if inst.AcceptData {
			sb.WriteString("    accept\n")
		}

		if inst.AuthKey != "" {
			sb.WriteString("\n    authentication {\n")
			authType := "PASS"
			if inst.AuthType == "md5" {
				authType = "AH"
			}
			sb.WriteString(fmt.Sprintf("        auth_type %s\n", authType))
			sb.WriteString(fmt.Sprintf("        auth_pass %s\n", inst.AuthKey))
			sb.WriteString("    }\n")
		}

		if len(inst.VirtualAddresses) > 0 {
			sb.WriteString("\n    virtual_ipaddress {\n")
			for _, vip := range inst.VirtualAddresses {
				// Add /24 if not already CIDR
				addr := vip
				if !strings.Contains(addr, "/") {
					addr += "/32"
				}
				sb.WriteString(fmt.Sprintf("        %s dev %s\n", addr, inst.Interface))
			}
			sb.WriteString("    }\n")
		}

		if inst.TrackInterface != "" {
			sb.WriteString("\n    track_interface {\n")
			weight := -50
			if inst.TrackPriorityCost > 0 {
				weight = -inst.TrackPriorityCost
			}
			sb.WriteString(fmt.Sprintf("        %s weight %d\n", inst.TrackInterface, weight))
			sb.WriteString("    }\n")
		}

		sb.WriteString("}\n\n")
	}

	return sb.String()
}

// Status reads the keepalived status and returns a formatted string.
func Status() (string, error) {
	out, err := exec.Command("systemctl", "is-active", "keepalived").Output()
	if err != nil {
		return "keepalived: not running\n", nil
	}
	state := strings.TrimSpace(string(out))
	if state != "active" {
		return fmt.Sprintf("keepalived: %s\n", state), nil
	}

	// Try to read keepalived stats
	statsFile := "/tmp/keepalived.stats"
	if data, err := os.ReadFile(statsFile); err == nil {
		return fmt.Sprintf("keepalived: active\n\n%s", string(data)), nil
	}

	// Fall back to just showing the config
	confData, err := os.ReadFile(keepalivedConf)
	if err != nil {
		return "keepalived: active (config not readable)\n", nil
	}

	return fmt.Sprintf("keepalived: active\n\nConfig:\n%s", string(confData)), nil
}
